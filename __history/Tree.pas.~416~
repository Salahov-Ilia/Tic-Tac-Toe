unit Tree;

interface
uses System.SysUtils, System.Variants, System.Classes, Wintypes;
  type
    pNode = ^TNode; //Указатель на TNode
    TData = array [0..2,0..2] of integer;//тип поля игры
    TField = array of TPoint;//тип массива свободных полей

   //Класс Узла-----------------------------------------------------------------

    TNode = class
    private
    // Поля
      FData: TData;  //Поле Данных
      FParent:pNode; //Родитель
      FVertKey:integer; //Ключ по вертикали
      FHorzKey:integer; //Ключ по горизонтали
      FKey:integer;
      FCountChild:integer;    //Кол-во потомков
      FLinks:array of pNode; //Поле  указателей на потомков на потомков
      CoordinatesEmptyField:TField; //массив свободных полей

    // Чтение-запись
    function GetLinks(index:integer):pNode;        // Чтение указателей на потомков
    procedure SetLinks(index:integer;value:pNode); // Запись указателей потомков

    function GetData :TData;       //Чтение Состояния игры
    procedure SetData (Data:TData);//Запись состояния игры


    public
    // Свойства
      property Parent:pNode read FParent write FParent;
      property Data :TData read GetData write SetData;
      property Key:integer read FKey write FKey;
      property CountChild:integer read FCountChild write FCountChild;
      property Links[index:integer]:pNode read GetLinks write SetLinks;
      property VertKey:integer read FVertKey write FVertKey;
      property HorzKey:integer read FHorzKey write FHorzKey;


    // Конструкторы
      constructor Create();overload;// Пустой конструктор
      constructor Create(Data:TData);overload;// Инициализатор данных
      constructor Create(Data:TData;CountChild:integer);overload; //Инициализатор данных и потомков(ссылки пустые)
      constructor Create(Data:TData;CountChild:integer; Parent:pNode);overload;//Инициализатор данных, родителя узла и потомков(ссылки пустые)
    //--------------------------------------------------------------------------
    end;


    TTree = class
      private
      // Поля
       FRoot:pNode;// Корень дерева

      function KeyWin(Node:pNode): Integer;
      public
      property Root:pNode read FRoot write FRoot;
      // Конструктор
        constructor Create();

      // Деструктор
        destructor Destroy;

      //Инициализация дерева
        procedure InitializationTree(Root: pNode; Data:TData; CountChild:integer; Parent:pNode);

      //Поиск в пространстве состояний
        function SearchState(Root:pNode; Data: TData):TData;

    end;

implementation

{ TNode }

 // Реализация класса узла------------------------------------------------------
constructor TNode.Create;
var
  I, j: Integer;
begin
for I := 0 to 2 do
for j := 0 to 2 do
      FData[i,j]:=0 ;
      FCountChild:=0;
      FLinks:=nil;
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data: TData );
begin
      FData:= Data;
      FCountChild:=0;
      FLinks:=nil;
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data:TData; CountChild: integer);
begin
      FData:= Data;
      FCountChild:=CountChild;
      SetLength(FLinks, CountChild); // Выделение памяти под массив
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data: TData; CountChild: integer; Parent: pNode);
var
  I: Integer;
  j, l: Integer;
begin

      FData:= Data;
      FCountChild:=CountChild;
      SetLength(FLinks, CountChild); // Выделение памяти под массив
      FVertKey:=0;
      FHorzKey:=0;
      FParent:=Parent;
       l:=0;

      //Если есть родитель, то массиву свободных полей присваем массив родителя
      if Parent<>nil then
        begin
             SetLength(CoordinatesEmptyField, length(FParent^.CoordinatesEmptyField));//выделение памяти
             CoordinatesEmptyField:=FParent^.CoordinatesEmptyField;//присваиваем массив
        end
                      else
       //если нет, то присваем массиву все клетки(т.к. это корень всего дерева)
       begin
             SetLength(CoordinatesEmptyField, FCountChild); //выделение памяти
             for I := 0 to 2 do
               for j := 0 to 2 do
                begin
                  if FData[i,j]=0 then
                 begin
                  CoordinatesEmptyField[l].X:=i;
                  CoordinatesEmptyField[l].Y:=j;
                  l:=l+1;
                 end;
                end;

       end;
end;


function TNode.GetData: TData;
begin
      Getdata:= FData;
end;


function TTree.KeyWin(Node:pNode): Integer;

function vert(data:TData):integer;
var i, value:integer;

begin
value:=3;
for I := 0 to 2 do
    if ((Data[i,0]=2) and (Data[i,1]=2) and (Data[i,2]=0)) or ((Data[i,0]=0) and (Data[i,1]=2) and (Data[i,2]=2)) or ((Data[i,0]=2) and (Data[i,1]=2) and (Data[i,2]=2)) or ((Data[i,0]=2) and (Data[i,1]=0) and (Data[i,2]=2)) then
       begin
         if value>1 then
        value:=4
       end
        else
    if ((Data[i,0]=1) and (Data[i,1]=1) and (Data[i,2]=0)) or ((Data[i,0]=0) and (Data[i,1]=1) and (Data[i,2]=1)) or ((Data[i,0]=1) and (Data[i,1]=1) and (Data[i,2]=1)) or ((Data[i,0]=1) and (Data[i,1]=0) and (Data[i,2]=1))then
        begin

           value:=1;
        end
        else
    if ((Data[i,0]=1) and (Data[i,1]=1) and (Data[i,2]=2)) or ((Data[i,0]=2) and (Data[i,1]=1) and (Data[i,2]=1)) or ((Data[i,0]=2) and (Data[i,1]=2) and (Data[i,2]=1)) or ((Data[i,0]=1) and (Data[i,1]=2) and (Data[i,2]=2)) then
       begin
         if value>1 then
           value:=2;
        end
        else
      if value>1 then
       value:=3;

   result:=value;
   end;
   function horz(data:TData):integer;
var i, value:integer;

begin
value:=3;
for I := 0 to 2 do
    if ((Data[0, i]=2) and (Data[1,i]=2) and (Data[2,i]=0)) or ((Data[0, i]=0) and (Data[1,i]=2) and (Data[2,i]=2)) or ((Data[0,i]=2) and (Data[1,i]=2) and (Data[2,i]=2)) or ((Data[0, i]=2) and (Data[1, i]=0) and (Data[2, i]=2)) then
       begin
        if value>1 then

        value:=4
       end
        else
    if ((Data[0, i]=1) and (Data[1, i]=1) and (Data[2, i]=0)) or ((Data[0, i]=0) and (Data[1, i]=1) and (Data[2, i]=1)) or ((Data[0, i]=1) and (Data[1, i]=1) and (Data[2, i]=1)) or ((Data[0, i]=1) and (Data[1, i]=2) and (Data[2, i]=2)) then
        begin

           value:=1;
        end
        else
    if ((Data[0, i]=1) and (Data[1, i]=1) and (Data[2, i]=2)) or ((Data[0, i]=2) and (Data[1, i]=1) and (Data[2, i]=1)) or ((Data[0, i]=2) and (Data[1, i]=2) and (Data[2, i]=1)) or ((Data[0, i]=1) and (Data[1, i]=2) and (Data[2, i]=2)) then
       begin
        if value>1 then
           value:=2;
        end
        else
    if value>1 then
       value:=3;

   result:=value;
   end;
var
 UpToDown, LeftToRight :integer;
begin

UpToDown:=vert(node^.Data);
LeftToRight:=horz(node^.Data);

if UpToDown>=LeftToRight then
   result:=UpToDown else
   result:=LeftToRight;

if UpToDown=1 then
   result:=UpToDown else
if LeftToRight=1 then
   result:=LeftToRight;
end;

function TNode.GetLinks(index: integer): pNode;
begin
     result:=FLinks[index];
end;

procedure TNode.SetData(Data:TData);
begin
     FData:=Data;
end;


procedure TNode.SetLinks(index: integer; value: pNode);
begin
     FLinks[index]:=value;
end;
//------------------------------------------------------------------------------


{ TTree }

 // Реализация класса дерева----------------------------------------------------
constructor TTree.Create;
begin
   FRoot:=nil;
   new(FRoot);
end;


destructor TTree.destroy;
begin
    FRoot:=nil;
    dispose(FRoot);
end;



procedure TTree.InitializationTree(Root: pNode; Data:TData; CountChild: integer; Parent:pNode);

//----------------------------Генрация поля-------------------------------------
function Generation(Node:pNode; cross,toe:integer):TData;
var value, j:integer;
 begin
   value:=0;
   //new(Node);
   randomize;
   value:=random(length(Node^.CoordinatesEmptyField));

   Result:=Node^.Data;

   //Выбор хода и присваивание случайному полю (из массива свободных клеток) 1 или 2
  if length(Node^.CoordinatesEmptyField)<>0 then
  begin
   if (cross>toe)  then
       Result[Node^.Parent^.CoordinatesEmptyField[value].X,Node^.Parent^.CoordinatesEmptyField[value].Y]:=2
                   else
       Result[Node^.Parent^.CoordinatesEmptyField[value].X,Node^.Parent^.CoordinatesEmptyField[value].Y]:=1;

   //Сдвиг элементов влево, которые находятся правее от присвоенного
   for j := value to high(Node^.Parent^.CoordinatesEmptyField) do

     if j<>high(Node^.Parent^.CoordinatesEmptyField) then
         begin

           //Сдвиг координат у узла
           Node^.CoordinatesEmptyField[j].X:=Node^.CoordinatesEmptyField[j+1].X;
           Node^.CoordinatesEmptyField[j].Y:=Node^.CoordinatesEmptyField[j+1].Y;

           //Сдвиг координат у родителя узла
           Node^.Parent^.CoordinatesEmptyField[j].X:=Node^.Parent^.CoordinatesEmptyField[j+1].X;
           Node^.Parent^.CoordinatesEmptyField[j].Y:=Node^.Parent^.CoordinatesEmptyField[j+1].Y;
         end;

      //Удаление крайнего элемента
     setlength(Node^.CoordinatesEmptyField, length(Node^.CoordinatesEmptyField)-1);
     setlength(Node^.Parent^.CoordinatesEmptyField, length(Node^.Parent^.CoordinatesEmptyField)-1);
  end;
 end;
 //-----------------------------------------------------------------------------

var
  I, k: Integer;
  cross,toe:byte;
  begin
   cross:=0;
   toe:=0;


   // Создаем корень------------------------
       Root^:=Tnode.Create(Data,CountChild, Parent);


      if Root^.Parent<>nil then
        begin

          //Считаем кол-во крестиков и ноликов
           for i := 0 to 2 do
            for k := 0 to 2 do
              begin
                    if Root^.Parent^.Data[i,k]=1 then
                       cross:=cross+1 else
                    if Root^.Parent^.Data[i,k]=2 then
                       toe:=toe+1;
              end;

           //Генерируем поле для этого узла
           Root^.Data:=Generation(Root, cross, toe);
        end;

        Root^.Key:=KeyWin(Root);

        //Создание потомков
      if Root^.CountChild>0 then
        begin
             for I := 0 to Root^.CountChild-1 do
                 if Root^.Links[i]=nil then
                   begin
                      Root^.Links[i]:=new(pNode);
                      InitializationTree( Root^.Links[i], Root^.Data, Root^.CountChild-1, Root);
                   end;

        end;


 end;



function TTree.SearchState(Root:pNode; Data: TData):TData;

//------------------------------------------------------------------------------
  function Compare(Data1:TData; Data2:TData):boolean;
  var J, k, n: Integer;
  begin
     n:=0;
     result:=false;

      for J := 0 to 2 do
        for k := 0 to 2 do
        if data1[j,k]=data2[j,k] then
           n:=n+1;

           if n=9 then
              result:=true;
  end;
//------------------------------------------------------------------------------
var
  I: Integer;
  value:TData;
  max:integer;
begin
max:=4;
  for I := 0 to Root^.CountChild-1 do
      if max<Root^.Links[i]^.Key then
      begin
       max:=Root^.Links[i]^.Key;
        value:=Root^.Links[i]^.Data;
      end;

      if Root^.Key=1 then
        begin
          for I := 0 to Root^.CountChild-1 do
              if Root^.Links[i]^.Key=2 then
              value:=Root^.Links[i]^.Data;
        end;
   result:=value;
end;

//------------------------------------------------------------------------------
end.
