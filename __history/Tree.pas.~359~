unit Tree;

interface
uses System.SysUtils, System.Variants, System.Classes, Wintypes;
  type
    pNode = ^TNode; //Указатель на TNode
    TData = array [0..2,0..2] of integer;//тип поля игры
    TField = array of TPoint;//тип массива свободных полей

   //Класс Узла-----------------------------------------------------------------

    TNode = class
    private
    // Поля
      FData: TData;  //Поле Данных
      FParent:pNode; //Родитель
      FVertKey:integer; //Ключ по вертикали
      FHorzKey:integer; //Ключ по горизонтали
      FCountChild:integer;    //Кол-во потомков
      FLinks:array of pNode; //Поле  указателей на потомков на потомков
      CoordinatesEmptyField:TField; //массив свободных полей

    // Чтение-запись
    function GetLinks(index:integer):pNode;        // Чтение указателей на потомков
    procedure SetLinks(index:integer;value:pNode); // Запись указателей потомков

    function GetData :TData;       //Чтение Состояния игры
    procedure SetData (Data:TData);//Запись состояния игры


    public
    // Свойства
      property Parent:pNode read FParent write FParent;
      property Data :TData read GetData write SetData;
      property CountChild:integer read FCountChild write FCountChild;
      property Links[index:integer]:pNode read GetLinks write SetLinks;
      property VertKey:integer read FVertKey write FVertKey;
      property HorzKey:integer read FHorzKey write FHorzKey;

      function KeyWin:byte;
    // Конструкторы
      constructor Create();overload;// Пустой конструктор
      constructor Create(Data:TData);overload;// Инициализатор данных
      constructor Create(Data:TData;CountChild:integer);overload; //Инициализатор данных и потомков(ссылки пустые)
      constructor Create(Data:TData;CountChild:integer; Parent:pNode);overload;//Инициализатор данных, родителя узла и потомков(ссылки пустые)
    //--------------------------------------------------------------------------
    end;


    TTree = class
      private
      // Поля
       FRoot:pNode;// Корень дерева


      public
      property Root:pNode read FRoot write FRoot;
      // Конструктор
        constructor Create();

      // Деструктор
        destructor Destroy;

      //Инициализация дерева
        procedure InitializationTree(Root: pNode; Data:TData; CountChild:integer; Parent:pNode);

      //Поиск в пространстве состояний
        function SearchState(Root:pNode; Data: TData):TData;

    end;

implementation

{ TNode }

 // Реализация класса узла------------------------------------------------------
constructor TNode.Create;
var
  I, j: Integer;
begin
for I := 0 to 2 do
for j := 0 to 2 do
      FData[i,j]:=0 ;
      FCountChild:=0;
      FLinks:=nil;
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data: TData );
begin
      FData:= Data;
      FCountChild:=0;
      FLinks:=nil;
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data:TData; CountChild: integer);
begin
      FData:= Data;
      FCountChild:=CountChild;
      SetLength(FLinks, CountChild); // Выделение памяти под массив
      FVertKey:=0;
      FHorzKey:=0;
end;

constructor TNode.Create(Data: TData; CountChild: integer; Parent: pNode);
var
  I: Integer;
  j, l: Integer;
begin

      FData:= Data;
      FCountChild:=CountChild;
      SetLength(FLinks, CountChild); // Выделение памяти под массив
      FVertKey:=0;
      FHorzKey:=0;
      FParent:=Parent;
       l:=0;

      //Если есть родитель, то массиву свободных полей присваем массив родителя
      if Parent<>nil then
        begin
             SetLength(CoordinatesEmptyField, length(FParent^.CoordinatesEmptyField));//выделение памяти
             CoordinatesEmptyField:=FParent^.CoordinatesEmptyField;//присваиваем массив
        end
                      else
       //если нет, то присваем массиву все клетки(т.к. это корень всего дерева)
       begin
             SetLength(CoordinatesEmptyField, CountChild); //выделение памяти
             for I := 0 to 2 do
               for j := 0 to 2 do
                begin
                  CoordinatesEmptyField[l].X:=i;
                  CoordinatesEmptyField[l].Y:=j;
                  l:=l+1;
                end;

       end;
end;


function TNode.GetData: TData;
begin
      Getdata:= FData;
end;


function TNode.KeyWin: byte;
begin


end;

function TNode.GetLinks(index: integer): pNode;
begin
     result:=FLinks[index];
end;

procedure TNode.SetData(Data:TData);
begin
     FData:=Data;
end;


procedure TNode.SetLinks(index: integer; value: pNode);
begin
     FLinks[index]:=value;
end;
//------------------------------------------------------------------------------


{ TTree }

 // Реализация класса дерева----------------------------------------------------
constructor TTree.Create;
begin
   //FRoot:=nil;
   new(FRoot);
end;


destructor TTree.destroy;
begin
    FRoot:=nil;
end;



procedure TTree.InitializationTree(Root: pNode; Data:TData; CountChild: integer; Parent:pNode);

//----------------------------Генрация поля-------------------------------------
function Generation(Node:pNode; cross,toe:integer):TData;
var value, j:integer;
 begin
   value:=0;
   //new(Node);
   randomize;
   value:=random(length(Node^.CoordinatesEmptyField));

   Result:=Node^.Data;

   //Выбор хода и присваивание случайному полю (из массива свободных клеток) 1 или 2
  if length(Node^.CoordinatesEmptyField)<>0 then
  begin
   if (cross>toe)  then
       Result[Node^.Parent^.CoordinatesEmptyField[value].X,Node^.Parent^.CoordinatesEmptyField[value].Y]:=2
                   else
       Result[Node^.Parent^.CoordinatesEmptyField[value].X,Node^.Parent^.CoordinatesEmptyField[value].Y]:=1;

   //Сдвиг элементов влево, которые находятся правее от присвоенного
   for j := value to high(Node^.Parent^.CoordinatesEmptyField) do

     if j<>high(Node^.Parent^.CoordinatesEmptyField) then
         begin

           //Сдвиг координат у узла
           Node^.CoordinatesEmptyField[j].X:=Node^.CoordinatesEmptyField[j+1].X;
           Node^.CoordinatesEmptyField[j].Y:=Node^.CoordinatesEmptyField[j+1].Y;

           //Сдвиг координат у родителя узла
           Node^.Parent^.CoordinatesEmptyField[j].X:=Node^.Parent^.CoordinatesEmptyField[j+1].X;
           Node^.Parent^.CoordinatesEmptyField[j].Y:=Node^.Parent^.CoordinatesEmptyField[j+1].Y;
         end;

      //Удаление крайнего элемента
     setlength(Node^.CoordinatesEmptyField, length(Node^.CoordinatesEmptyField)-1);
     setlength(Node^.Parent^.CoordinatesEmptyField, length(Node^.Parent^.CoordinatesEmptyField)-1);
  end;
 end;
 //-----------------------------------------------------------------------------

var
  I, j, k: Integer;
  cross,toe:byte;
  begin
   cross:=0;
   toe:=0;


   // Создаем корень------------------------
       Root^:=Tnode.Create(Data,CountChild, Parent);


      if Root^.Parent<>nil then
        begin

          //Считаем кол-во крестиков и ноликов
           for j := 0 to 2 do
            for k := 0 to 2 do
              begin
                    if Root^.Parent^.Data[j,k]=1 then
                       cross:=cross+1 else
                    if Root^.Parent^.Data[j,k]=2 then
                       toe:=toe+1;
              end;

           //Генерируем поле для этого узла
           Root^.Data:=Generation(Root, cross, toe);
        end;



        //Создание потомков
      if Root^.CountChild>0 then
        begin
             for I := 0 to Root^.CountChild-1 do
                 if Root^.Links[i]=nil then
                   begin
                      Root^.Links[i]:=new(pNode);
                      InitializationTree( Root^.Links[i], Root^.Data, Root^.CountChild-1, Root);
                   end;

        end;


 end;



function TTree.SearchState(Root:pNode; Data: TData):TData;
var
  I: Integer;
begin


      //result:=FRoot^.Links[0]^.Data;

end;

//------------------------------------------------------------------------------
end.
